/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { RoboMLanguageAstType } from '../language/generated/ast.js';
import * as InterfaceAST from '../language/generated/ast.js';
import * as ClassAST from './robo-m-language-visitor.js';
import { RoboMLanguageVisitor } from './robo-m-language-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof RoboMLanguageAstType]?: (node: RoboMLanguageAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class RoboMLanguageAcceptWeaver {
    
    private readonly checks: Weaver = {
        ArithmeticExpression: this.weaveArithmeticExpression,
        ComparisonExpression: this.weaveComparisonExpression,
        BooleanLiteral: this.weaveBooleanLiteral,
        NumberLiteral: this.weaveNumberLiteral,
        SensorRead: this.weaveSensorRead,
        UnaryExpression: this.weaveUnaryExpression,
        UnitExpression: this.weaveUnitExpression,
        VariableReference: this.weaveVariableReference,
        MyFunction: this.weaveMyFunction,
        Parameter: this.weaveParameter,
        Program: this.weaveProgram,
        Assignment: this.weaveAssignment,
        FunctionCall: this.weaveFunctionCall,
        Movement: this.weaveMovement,
        Rotation: this.weaveRotation,
        SetSpeed: this.weaveSetSpeed,
        Condition: this.weaveCondition,
        Loop: this.weaveLoop,
        VariableDeclaration: this.weaveVariableDeclaration
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveArithmeticExpression(node : InterfaceAST.ArithmeticExpression) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitArithmeticExpression(node as unknown as ClassAST.ArithmeticExpression); }
    }
    
    weaveComparisonExpression(node : InterfaceAST.ComparisonExpression) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitComparisonExpression(node as unknown as ClassAST.ComparisonExpression); }
    }
    
    weaveBooleanLiteral(node : InterfaceAST.BooleanLiteral) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitBooleanLiteral(node as unknown as ClassAST.BooleanLiteral); }
    }
    
    weaveNumberLiteral(node : InterfaceAST.NumberLiteral) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitNumberLiteral(node as unknown as ClassAST.NumberLiteral); }
    }
    
    weaveSensorRead(node : InterfaceAST.SensorRead) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitSensorRead(node as unknown as ClassAST.SensorRead); }
    }
    
    weaveUnaryExpression(node : InterfaceAST.UnaryExpression) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitUnaryExpression(node as unknown as ClassAST.UnaryExpression); }
    }
    
    weaveUnitExpression(node : InterfaceAST.UnitExpression) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitUnitExpression(node as unknown as ClassAST.UnitExpression); }
    }
    
    weaveVariableReference(node : InterfaceAST.VariableReference) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitVariableReference(node as unknown as ClassAST.VariableReference); }
    }
    
    weaveMyFunction(node : InterfaceAST.MyFunction) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitMyFunction(node as unknown as ClassAST.MyFunction); }
    }
    
    weaveParameter(node : InterfaceAST.Parameter) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitParameter(node as unknown as ClassAST.Parameter); }
    }
    
    weaveProgram(node : InterfaceAST.Program) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitProgram(node as unknown as ClassAST.Program); }
    }
    
    weaveAssignment(node : InterfaceAST.Assignment) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitAssignment(node as unknown as ClassAST.Assignment); }
    }
    
    weaveFunctionCall(node : InterfaceAST.FunctionCall) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitFunctionCall(node as unknown as ClassAST.FunctionCall); }
    }
    
    weaveMovement(node : InterfaceAST.Movement) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitMovement(node as unknown as ClassAST.Movement); }
    }
    
    weaveRotation(node : InterfaceAST.Rotation) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitRotation(node as unknown as ClassAST.Rotation); }
    }
    
    weaveSetSpeed(node : InterfaceAST.SetSpeed) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitSetSpeed(node as unknown as ClassAST.SetSpeed); }
    }
    
    weaveCondition(node : InterfaceAST.Condition) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitCondition(node as unknown as ClassAST.Condition); }
    }
    
    weaveLoop(node : InterfaceAST.Loop) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitLoop(node as unknown as ClassAST.Loop); }
    }
    
    weaveVariableDeclaration(node : InterfaceAST.VariableDeclaration) : void {
        (<any> node).accept = (visitor: RoboMLanguageVisitor) => { return visitor.visitVariableDeclaration(node as unknown as ClassAST.VariableDeclaration); }
    }
    
}