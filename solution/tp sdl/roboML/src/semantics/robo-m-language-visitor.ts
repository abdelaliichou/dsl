/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, Reference, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the RoboMLanguage language.
 */
export interface RoboMLanguageVisitor {
    visitExpression(node : Expression) : any;
    visitBinaryExpression(node : BinaryExpression) : any;
    visitArithmeticExpression(node : ArithmeticExpression) : any;
    visitComparisonExpression(node : ComparisonExpression) : any;
    visitBooleanLiteral(node : BooleanLiteral) : any;
    visitNumberLiteral(node : NumberLiteral) : any;
    visitSensorRead(node : SensorRead) : any;
    visitUnaryExpression(node : UnaryExpression) : any;
    visitUnitExpression(node : UnitExpression) : any;
    visitVariableReference(node : VariableReference) : any;
    visitMyFunction(node : MyFunction) : any;
    visitParameter(node : Parameter) : any;
    visitProgram(node : Program) : any;
    visitStatement(node : Statement) : any;
    visitAssignment(node : Assignment) : any;
    visitCommand(node : Command) : any;
    visitFunctionCall(node : FunctionCall) : any;
    visitMovement(node : Movement) : any;
    visitRotation(node : Rotation) : any;
    visitSetSpeed(node : SetSpeed) : any;
    visitCondition(node : Condition) : any;
    visitLoop(node : Loop) : any;
    visitVariableDeclaration(node : VariableDeclaration) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the RoboMLanguage language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class RoboMLanguageValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: Program, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitExpression(node : Expression) : any;
    abstract visitBinaryExpression(node : BinaryExpression) : any;
    abstract visitArithmeticExpression(node : ArithmeticExpression) : any;
    abstract visitComparisonExpression(node : ComparisonExpression) : any;
    abstract visitBooleanLiteral(node : BooleanLiteral) : any;
    abstract visitNumberLiteral(node : NumberLiteral) : any;
    abstract visitSensorRead(node : SensorRead) : any;
    abstract visitUnaryExpression(node : UnaryExpression) : any;
    abstract visitUnitExpression(node : UnitExpression) : any;
    abstract visitVariableReference(node : VariableReference) : any;
    abstract visitMyFunction(node : MyFunction) : any;
    abstract visitParameter(node : Parameter) : any;
    abstract visitProgram(node : Program) : any;
    abstract visitStatement(node : Statement) : any;
    abstract visitAssignment(node : Assignment) : any;
    abstract visitCommand(node : Command) : any;
    abstract visitFunctionCall(node : FunctionCall) : any;
    abstract visitMovement(node : Movement) : any;
    abstract visitRotation(node : Rotation) : any;
    abstract visitSetSpeed(node : SetSpeed) : any;
    abstract visitCondition(node : Condition) : any;
    abstract visitLoop(node : Loop) : any;
    abstract visitVariableDeclaration(node : VariableDeclaration) : any;
}


/**
 * This function is used to register a validation visitor for the RoboMLanguage language.
 * It will register the `visitRoot` method as a validation check for the Program type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends RoboMLanguageValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.RoboMLanguageAstType> = {
        Program: (node, accept) => {
            visitor.visitRoot(node as Program, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated type with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these types allow it to exist statically, so we can take advantage of TypeScript's typing.
 * The references are overrided to use the visitor types instead of the Langium interfaces/types.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

type Acceptor = {
    accept: (visitor: RoboMLanguageVisitor) => any;
}

function isAcceptor(node: unknown): node is Acceptor {
    return typeof (node as any).accept === 'function';
}


export type Expression = Acceptor & ASTInterfaces.Expression

export function isExpression(node: unknown): node is Expression {
    return ASTInterfaces.isExpression(node) && isAcceptor(node);
}


export type BinaryExpression = Acceptor & Omit<ASTInterfaces.BinaryExpression, 'left' | 'right'> & {
    left: Expression;
    right: Expression;
}

export function isBinaryExpression(node: unknown): node is BinaryExpression {
    return ASTInterfaces.isBinaryExpression(node) && isAcceptor(node);
}


export type ArithmeticExpression = Acceptor & Omit<ASTInterfaces.ArithmeticExpression, 'left' | 'right' | 'operator'> & {
    left: Expression;
    right: Expression;
    operator: ArithmeticOperator;
}

export function isArithmeticExpression(node: unknown): node is ArithmeticExpression {
    return ASTInterfaces.isArithmeticExpression(node) && isAcceptor(node);
}


export type ComparisonExpression = Acceptor & Omit<ASTInterfaces.ComparisonExpression, 'left' | 'right' | 'operator'> & {
    left: Expression;
    right: Expression;
    operator: ComparisonOperator;
}

export function isComparisonExpression(node: unknown): node is ComparisonExpression {
    return ASTInterfaces.isComparisonExpression(node) && isAcceptor(node);
}


export type BooleanLiteral = Acceptor & ASTInterfaces.BooleanLiteral

export function isBooleanLiteral(node: unknown): node is BooleanLiteral {
    return ASTInterfaces.isBooleanLiteral(node) && isAcceptor(node);
}


export type NumberLiteral = Acceptor & ASTInterfaces.NumberLiteral

export function isNumberLiteral(node: unknown): node is NumberLiteral {
    return ASTInterfaces.isNumberLiteral(node) && isAcceptor(node);
}


export type SensorRead = Acceptor & Omit<ASTInterfaces.SensorRead, 'sensor' | 'unit'> & {
    sensor: SensorType;
    unit: DistanceUnit;
}

export function isSensorRead(node: unknown): node is SensorRead {
    return ASTInterfaces.isSensorRead(node) && isAcceptor(node);
}


export type UnaryExpression = Acceptor & Omit<ASTInterfaces.UnaryExpression, 'operator' | 'operand'> & {
    operator: UnaryOperator;
    operand: Expression;
}

export function isUnaryExpression(node: unknown): node is UnaryExpression {
    return ASTInterfaces.isUnaryExpression(node) && isAcceptor(node);
}


export type UnitExpression = Acceptor & Omit<ASTInterfaces.UnitExpression, 'unit' | 'value'> & {
    unit: DistanceUnit;
    value: Expression;
}

export function isUnitExpression(node: unknown): node is UnitExpression {
    return ASTInterfaces.isUnitExpression(node) && isAcceptor(node);
}


export type VariableReference = Acceptor & ASTInterfaces.VariableReference

export function isVariableReference(node: unknown): node is VariableReference {
    return ASTInterfaces.isVariableReference(node) && isAcceptor(node);
}


export type MyFunction = Acceptor & Omit<ASTInterfaces.MyFunction, '$container' | 'returnType' | 'parameters' | 'body'> & {
    $container: Program;
    returnType: ReturnType;
    parameters: Array<Parameter>;
    body: Array<Statement>;
}

export function isMyFunction(node: unknown): node is MyFunction {
    return ASTInterfaces.isMyFunction(node) && isAcceptor(node);
}


export type Parameter = Acceptor & Omit<ASTInterfaces.Parameter, '$container' | 'type'> & {
    $container: MyFunction;
    type: VariableType;
}

export function isParameter(node: unknown): node is Parameter {
    return ASTInterfaces.isParameter(node) && isAcceptor(node);
}


export type Program = Acceptor & Omit<ASTInterfaces.Program, 'entry' | 'functions'> & {
    entry: MyFunction;
    functions: Array<MyFunction>;
}

export function isProgram(node: unknown): node is Program {
    return ASTInterfaces.isProgram(node) && isAcceptor(node);
}


export type Statement = Acceptor & ASTInterfaces.Statement

export function isStatement(node: unknown): node is Statement {
    return ASTInterfaces.isStatement(node) && isAcceptor(node);
}


export type Assignment = Acceptor & Omit<ASTInterfaces.Assignment, 'value'> & {
    value: Expression;
}

export function isAssignment(node: unknown): node is Assignment {
    return ASTInterfaces.isAssignment(node) && isAcceptor(node);
}


export type Command = Acceptor & ASTInterfaces.Command

export function isCommand(node: unknown): node is Command {
    return ASTInterfaces.isCommand(node) && isAcceptor(node);
}


export type FunctionCall = Acceptor & Omit<ASTInterfaces.FunctionCall, 'arguments'> & {
    arguments: Array<Expression>;
}

export function isFunctionCall(node: unknown): node is FunctionCall {
    return ASTInterfaces.isFunctionCall(node) && isAcceptor(node);
}


export type Movement = Acceptor & Omit<ASTInterfaces.Movement, 'direction' | 'unit' | 'distance'> & {
    direction: Direction;
    unit: DistanceUnit;
    distance: Expression;
}

export function isMovement(node: unknown): node is Movement {
    return ASTInterfaces.isMovement(node) && isAcceptor(node);
}


export type Rotation = Acceptor & Omit<ASTInterfaces.Rotation, 'direction' | 'angle'> & {
    direction: RotationDirection;
    angle: Expression;
}

export function isRotation(node: unknown): node is Rotation {
    return ASTInterfaces.isRotation(node) && isAcceptor(node);
}


export type SetSpeed = Acceptor & Omit<ASTInterfaces.SetSpeed, 'unit' | 'speed'> & {
    unit: SpeedUnit;
    speed: Expression;
}

export function isSetSpeed(node: unknown): node is SetSpeed {
    return ASTInterfaces.isSetSpeed(node) && isAcceptor(node);
}


export type Condition = Acceptor & Omit<ASTInterfaces.Condition, 'condition' | 'thenBlock' | 'elseBlock'> & {
    condition: Expression;
    thenBlock: Array<Statement>;
    elseBlock: Array<Statement>;
}

export function isCondition(node: unknown): node is Condition {
    return ASTInterfaces.isCondition(node) && isAcceptor(node);
}


export type Loop = Acceptor & Omit<ASTInterfaces.Loop, 'condition' | 'body'> & {
    condition: Expression;
    body: Array<Statement>;
}

export function isLoop(node: unknown): node is Loop {
    return ASTInterfaces.isLoop(node) && isAcceptor(node);
}


export type VariableDeclaration = Acceptor & Omit<ASTInterfaces.VariableDeclaration, 'type' | 'initialValue'> & {
    type: VariableType;
    initialValue: Expression;
}

export function isVariableDeclaration(node: unknown): node is VariableDeclaration {
    return ASTInterfaces.isVariableDeclaration(node) && isAcceptor(node);
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated types.
 */

export type ArithmeticOperator = ArithmeticOperator_PLUS | ArithmeticOperator_MINUS | ArithmeticOperator_MULTIPLY | ArithmeticOperator_DIVIDE | ArithmeticOperator_MODULO;

export type ArithmeticOperator_DIVIDE = 'DIVIDE';

export type ArithmeticOperator_MINUS = 'MINUS';

export type ArithmeticOperator_MODULO = 'MODULO';

export type ArithmeticOperator_MULTIPLY = 'MULTIPLY';

export type ArithmeticOperator_PLUS = 'PLUS';

export type ComparisonOperator = ComparisonOperator_LESS | ComparisonOperator_LESS_EQ | ComparisonOperator_GREATER | ComparisonOperator_GREATER_EQ | ComparisonOperator_EQUALS | ComparisonOperator_NOT_EQUALS;

export type ComparisonOperator_EQUALS = 'EQUALS';

export type ComparisonOperator_GREATER = 'GREATER';

export type ComparisonOperator_GREATER_EQ = 'GREATER_EQ';

export type ComparisonOperator_LESS = 'LESS';

export type ComparisonOperator_LESS_EQ = 'LESS_EQ';

export type ComparisonOperator_NOT_EQUALS = 'NOT_EQUALS';

export type Direction = Direction_FORWARD | Direction_BACKWARD | Direction_LEFT | Direction_RIGHT;

export type Direction_BACKWARD = 'BACKWARD';

export type Direction_FORWARD = 'FORWARD';

export type Direction_LEFT = 'LEFT';

export type Direction_RIGHT = 'RIGHT';

export type DistanceUnit = DistanceUnit_CM | DistanceUnit_MM;

export type DistanceUnit_CM = 'CM';

export type DistanceUnit_MM = 'MM';

export type EDouble = number;

export type ReturnType = ReturnType_VOID | ReturnType_NUMBER | ReturnType_BOOLEAN;

export type ReturnType_BOOLEAN = 'BOOLEAN';

export type ReturnType_NUMBER = 'NUMBER';

export type ReturnType_VOID = 'VOID';

export type RotationDirection = RotationDirection_CLOCK | RotationDirection_COUNTERCLOCK;

export type RotationDirection_CLOCK = 'CLOCK';

export type RotationDirection_COUNTERCLOCK = 'COUNTERCLOCK';

export type SensorType = SensorType_TIMESTAMP | SensorType_DISTANCE;

export type SensorType_DISTANCE = 'DISTANCE';

export type SensorType_TIMESTAMP = 'TIMESTAMP';

export type SpeedUnit = SpeedUnit_MM_PER_SEC | SpeedUnit_CM_PER_SEC;

export type SpeedUnit_CM_PER_SEC = 'CM_PER_SEC';

export type SpeedUnit_MM_PER_SEC = 'MM_PER_SEC';

export type UnaryOperator = UnaryOperator_MINUS | UnaryOperator_NOT;

export type UnaryOperator_MINUS = 'MINUS';

export type UnaryOperator_NOT = 'NOT';

export type VariableType = VariableType_NUMBER | VariableType_BOOLEAN;

export type VariableType_BOOLEAN = 'BOOLEAN';

export type VariableType_NUMBER = 'NUMBER';
